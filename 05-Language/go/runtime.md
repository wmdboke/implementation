#### runtime理解

runtime 类似jam提供了跨平台能力，go执行程序运行在runtime之上，编译时已经链接到了二进制中。

###### 协程调度模型：

1. G： goroutine 轻量级的线程，保存了上下文

2. P：逻辑处理器，将goroutine绑定到P的的本地队列才能被调度，提供了执行环境，如内存分配 memche, 任务队列

3. M：计算资源，真正的系统线程，存放了go程序与CPU交互的数据结构

4. 全局队列： 未分配的P跟G。 P跟M都可以取出G

5. 本地队列： 是P的队列，如果为空则从全局队列或者启动队列获取G来补充。

###### 垃圾回收GC

- 引用计数

- 标记清扫： go采用
  
  未引用的不立马清除，首先只是标记，知道内存耗尽，挂起程序，清除未引用的对象。有一个问题就是 STW, go采用三色标记法来优化STW.
  
  ```
  三色标记： 白，灰，黑。  是跟程序并发执行的。
  开始都是白色的，然后追踪root可达的对象标记为灰色，加入灰色队列
  然后遍历灰色队列中的对象，并将自身标记为黑色
  清除所有不可达的白色对象
  ```

- 复制收集

###### 内存分配

- **Tcmalloc**算法
  
  Tcmalloc(Thread Caching Malloc) 是 google 为 c 语言开发的运行时内存分配算法. 其核心思想是多级管理，从而降低锁的粒度. Go runtime 的内存分配就采用了 Tcmalloc 算法.

- **golang 内存分配**

        go启动申请3块空间 spans,bitmap,arena.
