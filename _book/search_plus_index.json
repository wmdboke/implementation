{"./":{"url":"./","title":"Introduction","keywords":"","body":" 一旦触发，必须到达！ OS network database Application language Devops 生成新目录结构：gitbook init 安装插件： gitbook install 浏览器浏览：gitbook serve 构建书籍：gitbook build © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:58:39 "},"01-OS/":{"url":"01-OS/","title":"OS","keywords":"","body":"OS README © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:21:54 "},"02-network/":{"url":"02-network/","title":"Network","keywords":"","body":"从头开始学网络 namespace tun/tap route 网卡配置文件 © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:25:07 "},"02-network/namespace.html":{"url":"02-network/namespace.html","title":"namespace","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-05-23 06:19:56 "},"02-network/tun-tap.html":{"url":"02-network/tun-tap.html","title":"tun/tap","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-05-23 06:20:03 "},"02-network/route.html":{"url":"02-network/route.html","title":"route","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-05-23 06:20:11 "},"02-network/centos网卡配置文件.html":{"url":"02-network/centos网卡配置文件.html","title":"网卡配置文件","keywords":"","body":"文件路径：/etc/sysconfig/network-scripts/ifcfg-eth0配置IP、掩码、网关:ethX DEVICE=\"eth0\" 此配置关联至的设备。设备名要与文件ifcfg-后ude内容保持一致 BOOTPROTO=none 引导协议：{none|static|dhcp|bootp} HWADDR=\"00:0C:29:26:62:92\" MAC地址：要与真实MAC地址保持一致，可省略 NM_CONTROLLED=\"yes\" 是否接受NetworkManager脚本控制：{yes|no} ONBOOT=\"yes\" 是否开机自动启动此网络设备{yes|no} TYPE=\"Ethernet\" 设备类型Etheraget Bridge（桥接） UUID=\"14351f7f-a726-4dfc-966e-dfb1f352f226\" 唯一标识，可省略 IPADDR= ip地址 NETMASK= 掩码 GATEWAY= 默认网关 DNS1= DNS1服务地址 IPV6INIT=no 是否开启ipv6 USERCTL=no 是否允许普通用户操作网卡 PEERDNS={yes|no} 是否允许DHCP服务分配地址时直接更新/etc/resolv。conf中的DNS服务器地址 © cc all right reserved，powered by GitbookUpdated at 2020-05-26 08:54:35 "},"03-databases/":{"url":"03-databases/","title":"Database","keywords":"","body":" redis memcache etcd mongodb © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:28:35 "},"04-Application/":{"url":"04-Application/","title":"Application","keywords":"","body":" front-end back-end © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:50:39 "},"04-Application/front-end/":{"url":"04-Application/front-end/","title":"front-end","keywords":"","body":"front-end © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:50:57 "},"04-Application/back-end/":{"url":"04-Application/back-end/","title":"back-end","keywords":"","body":"back-end microservice © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:51:53 "},"04-Application/back-end/micoservice/":{"url":"04-Application/back-end/micoservice/","title":"micoservice","keywords":"","body":"microservice © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:52:01 "},"05-language/":{"url":"05-language/","title":"Language","keywords":"","body":" Golang C++ vue © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:18:40 "},"05-language/go/":{"url":"05-language/go/","title":"Golang","keywords":"","body":"就是喜欢go语言，记录点点滴滴 gRPC reflect runtime tcp websocket sync.Map © cc all right reserved，powered by GitbookUpdated at 2020-07-18 09:07:20 "},"05-language/go/gRpc.html":{"url":"05-language/go/gRpc.html","title":"gRPC","keywords":"","body":"gRPC 与 rest api 的区别 底层都是采用http进行通信的。准确的说gRPC采用的是http2.0协议。 gRPC采用protobuf定义接口，有更严格的接口规范，而且protobuf是二进制传输更有效。 安装 git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text go get -u github.com/golang/protobuf/{proto,protoc-gen-go} git clone https://github.com/google/go-genproto.git $GOPATH/src/google.golang.org/genproto cd $GOPATH/src/ go install google.golang.org/grpc 示例： 步骤如下： lister, err : = net.Lister(tpye, endpoint ) // type = tcp / unix opts := []]grpc.ServerOption{} server := grpc.NewServer(opts...) proto_struct.RegisterServer(rpc.server, server) server.Serve(lister) handler 返回 pro.db.response 对象 syntax = \"proto3\"; package test; service Wait { rpc DoMD5(Req) returns (Rep); } message Req{ string fromjson = 1; } message Rep{ string md5str = 1; } protoc --go_out=plugins=grpc:./ ./test.proto //可以用不同的插件 // server.go package main import ( \"context\" \"crypto/md5\" \"fmt\" test \"go-test/grpc/proto\" \"google.golang.org/grpc/reflection\" \"log\" \"net\" \"google.golang.org/grpc\" ) // 业务实现逻辑的结构体 type server struct{} // 为server定义 DoMD5 方法 内部处理请求并返回结果 // 参数 (context.Context[固定], *test.Req[相应接口定义的请求参数]) // 返回 (*test.Res[相应接口定义的返回参数，必须用指针], error) func (s *server) DoMD5(ctx context.Context, in *test.Req) (*test.Rep, error) { fmt.Println(\"测试请求： \" + in.Fromjson) return &test.Rep{Md5Str: \"MD5 :\" + fmt.Sprintf(\"%x\", md5.Sum([]byte(in.Fromjson)))}, nil } func main() { lis, err := net.Listen(\"tcp\", \":8028\") //监听所有网卡8028端口的TCP连接 if err != nil { log.Fatalf(\"监听失败: %v\", err) } s := grpc.NewServer() //创建gRPC服务 /**注册接口服务 * 以定义proto时的service为单位注册，服务中可以有多个方法 * (proto编译时会为每个service生成Register***Server方法) * 包.注册服务方法(gRpc服务实例，包含接口方法的结构体[指针]) */ test.RegisterWaitServer(s, &server{}) /**如果有可以注册多个接口服务,结构体要实现对应的接口方法 * user.RegisterLoginServer(s, &server{}) * minMovie.RegisterFbiServer(s, &server{}) */ // 在gRPC服务器上注册反射服务 reflection.Register(s) // 将监听交给gRPC服务处理 err = s.Serve(lis) if err != nil { log.Fatalf(\"failed to serve: %v\", err) } } //client.go package main import ( \"context\" test \"go-test/grpc/proto\" \"google.golang.org/grpc\" \"log\" \"os\" ) func main() { // 建立连接到gRPC服务 conn, err := grpc.Dial(\"127.0.0.1:8028\", grpc.WithInsecure()) if err != nil { log.Fatalf(\"did not connect: %v\", err) } // 函数结束时关闭连接 defer conn.Close() // 创建Waiter服务的客户端 t := test.NewWaitClient(conn) // 模拟请求数据 res := \"test123\" // os.Args[1] 为用户执行输入的参数 如：go run ***.go 123 if len(os.Args) > 1 { res = os.Args[1] } // 调用gRPC接口 tr, err := t.DoMD5(context.Background(), &test.Req{Fromjson: res}) if err != nil { log.Fatalf(\"could not greet: %v\", err) } log.Printf(\"服务端响应: %s\", tr.Md5Str) } © cc all right reserved，powered by GitbookUpdated at 2020-05-31 07:40:07 "},"05-language/go/reflect.html":{"url":"05-language/go/reflect.html","title":"reflect","keywords":"","body":"反射 reflect 概念： 程序编译时，变量转换成内存地址，变量名不会编译到程序的可执行部分，运行程序时，程序无法获取自身的信息。 支持反射的语言在程序编译的时候，将变量的反射信息，如字段名，类型信息，结构体信息等整合到可执行文件中，并给程序提供访问反射信息的接口，这样就可以在程序运行的时候获取反射信息，并修改他们 go语言运行时候通过reflect包获取反射信息。 获取类型信息 package main import ( \"fmt\" \"reflect\" ) type Student struct { Name string Age int } func main() { var stu Student typeOfStu := reflect.TypeOf(stu) fmt.Println(typeOfStu.Name(), typeOfStu.Kind()) } 代码输出： Student struct 通过反射获取指针的元素类型 package main import ( \"fmt\" \"reflect\" ) type Student struct { Name string Age int } func main() { //定义一个Student类型的指针变量 var stu = &Student{Name:\"kitty\", Age: 20} //获取结构体实例的反射类型对象 typeOfStu := reflect.TypeOf(stu) //显示反射类型对象的名称和种类 fmt.Printf(\"name: '%v', kind: '%v'\\n\", typeOfStu.Name(), typeOfStu.Kind()) //取类型的元素 typeOfStu = typeOfStu.Elem() //显示反射类型对象的名称和种类 fmt.Printf(\"element name: '%v', element kind: '%v'\\n\", typeOfStu.Name(), typeOfStu.Kind()) } 输出： name: '', kind: 'ptr' element name: 'Student', element kind: 'struct' 通过反射获取结构体成员的类型 -方法 -说明 Field(i int) StructField 根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生宕机 NumField() int 返回结构体成员字段数量。当类型不是结构体或索引超界时发生宕机 FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机 FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时 发生宕机 FieldByNameFunc( match func(string) bool) (StructField,bool) 根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生宕机 type StructField struct { Name string // 字段名 PkgPath string // 字段路径 Type Type // 字段反射类型对象 Tag StructTag // 字段的结构体标签 Offset uintptr // 字段在结构体中的相对偏移 Index []int // Type.FieldByIndex中的返回的索引值 Anonymous bool // 是否为匿名字段 } package main import ( \"fmt\" \"reflect\" ) func main() { // 声明一个空结构体 type cat struct { Name string // 带有结构体tag的字段 Type int `json:\"type\" id:\"100\"` } // 创建cat的实例 ins := cat{Name: \"mimi\", Type: 1} // 获取结构体实例的反射类型对象 typeOfCat := reflect.TypeOf(ins) // 遍历结构体所有成员 for i := 0; i 通过反射获取值的信息 package main import ( \"fmt\" \"reflect\" ) //定义结构体 type Student struct { Name string Age int //嵌入字段 float32 bool next *Student } func main() { //值包装结构体 rValue := reflect.ValueOf(Student{ next: &Student{}, }) //获取字段数量 fmt.Println(\"NumField:\", rValue.NumField()) //获取索引为2的字段(float32字段) //注:经过测试发现Field(i)的参数索引是从0开始的， //并且是按照定义的结构体的顺序来的，而不是按照字段名字的ASCii码值来的 floatField := rValue.Field(2) //输出字段类型 fmt.Println(\"Field:\", floatField.Type()) //根据名字查找字段 fmt.Println(\"FieldByName(\\\"Age\\\").Type:\", rValue.FieldByName(\"Age\").Type()) //根据索引查找值中next字段的int字段的值 fmt.Println(\"FieldByIndex([]int{4, 0}).Type()\", rValue.FieldByIndex([]int{4, 0}).Type()) } 输出信息： NumField: 5 Field: float32 FieldByName(\"Age\").Type: int FieldByIndex([]int{4, 0}).Type() string 第 41 行，[]int{4,0} 中的 4 表示，在 Student 结构中索引值为 4 的成员，也就是 next。next 的类型为 Student，也是一个结构体，因此使用 []int{4,0} 中的 0 继续在 next 值的基础上索引，结构为 Student 中索引值为 0 的 Name 字段，类型为 string。 判断反射值的空和有效性 package main import ( \"fmt\" \"reflect\" ) func main() { //*int的空指针 var a *int fmt.Println(\"var a *int:\", reflect.ValueOf(a).IsNil()) //nil值 fmt.Println(\"nil:\", reflect.ValueOf(nil).IsValid()) //*int类型的空指针 fmt.Println(\"(*int)(nil):\", reflect.ValueOf((*int)(nil)).Elem().IsValid()) //实例化一个结构体 s := struct {}{} //尝试从结构体中查找一个不存在的字段 fmt.Println(\"不存在的结构体成员:\", reflect.ValueOf(s).FieldByName(\"\").IsValid()) //尝试从结构体中查找一个不存在的方法 fmt.Println(\"不存在的方法:\", reflect.ValueOf(s).MethodByName(\"\").IsValid()) //实例化一个map m := map[int]int{} //尝试从map中查找一个不存在的键 fmt.Println(\"不存在的键:\", reflect.ValueOf(m).MapIndex(reflect.ValueOf(3)).IsValid()) } 输出结果: var a *int: true nil: false (*int)(nil): false 不存在的结构体成员: false 不存在的方法: false 不存在的键: false 通过反射修改变量的值 可被寻址： package main import ( \"fmt\" \"reflect\" ) func main() { //声明整形变量a并赋初值 var a int = 1024 //获取变量a的反射值对象 rValue := reflect.ValueOf(&a) //取出a地址的元素(a的值) rValue = rValue.Elem() //尝试将a修改为1 rValue.SetInt(1) //打印a的值 fmt.Println(rValue.Int()) } 可被导出： package main import ( \"fmt\" \"reflect\" ) func main() { type dog struct { LegCount int } //获取dog实例的反射值对象 valueOfDog := reflect.ValueOf(&dog{}) //// 取出dog实例地址的元素 valueOfDog = valueOfDog.Elem() //获取legCount字段的值 vLegCount := valueOfDog.FieldByName(\"LegCount\") //尝试设置legCount的值 vLegCount.SetInt(4) fmt.Println(vLegCount.Int()) } 通过类型信息创建实例 package main import ( \"fmt\" \"reflect\" ) func main() { var a int //取变量a的反射类型对象 typeOfA := reflect.TypeOf(a) //根据反射类型对象创建类型实例 aIns := reflect.New(typeOfA) //输出Value的类型和种类 fmt.Println(aIns.Type(), aIns.Kind()) } 代码输出结果如下 *int ptr 通过反射调用函数 package main import ( \"fmt\" \"reflect\" ) //普通函数 func add(a, b int) int { return a + b } func main() { //将函数包装为反射值对象 funcValue := reflect.ValueOf(add) //构造函数参数，传入两个整形值 paramList := []reflect.Value{reflect.ValueOf(2), reflect.ValueOf(3)} //反射调用函数 retList := funcValue.Call(paramList) fmt.Println(retList[0].Int()) } 通过反射调用方法 package main import ( \"fmt\" \"reflect\" ) type MyMath struct { Pi float64 } //普通函数 func (myMath MyMath) Sum(a, b int) int { return a + b } func (myMath MyMath) Dec(a, b int) int { return a - b } func main() { var myMath = MyMath{Pi:3.14159} //获取myMath的值对象 rValue := reflect.ValueOf(myMath) //获取到该结构体有多少个方法 //numOfMethod := rValue.NumMethod() //构造函数参数，传入两个整形值 paramList := []reflect.Value{reflect.ValueOf(30), reflect.ValueOf(20)} //调用结构体的第一个方法Method(0) //注意:在反射值对象中方法索引的顺序并不是结构体方法定义的先后顺序 //而是根据方法的ASCII码值来从小到大排序，所以Dec排在第一个，也就是Method(0) result := rValue.Method(0).Call(paramList) fmt.Println(result[0].Int()) } 代码输出结果为: 10 © cc all right reserved，powered by GitbookUpdated at 2020-05-27 15:28:51 "},"05-language/go/runtime.html":{"url":"05-language/go/runtime.html","title":"runtime","keywords":"","body":"runtime理解 runtime 类似jam提供了跨平台能力，go执行程序运行在runtime之上，编译时已经链接到了二进制中。 协程调度模型： G： goroutine 轻量级的线程，保存了上下文 P：逻辑处理器，将goroutine绑定到P的的本地队列才能被调度，提供了执行环境，如内存分配 memche, 任务队列 M：计算资源，真正的系统线程，存放了go程序与CPU交互的数据结构 全局队列： 未分配的P跟G。 P跟M都可以取出G 本地队列： 是P的队列，如果为空则从全局队列或者启动队列获取G来补充。 垃圾回收GC 引用计数 标记清扫： go采用 未引用的不立马清除，首先只是标记，知道内存耗尽，挂起程序，清除未引用的对象。有一个问题就是 STW, go采用三色标记法来优化STW. 三色标记： 白，灰，黑。 是跟程序并发执行的。 开始都是白色的，然后追踪root可达的对象标记为灰色，加入灰色队列 然后遍历灰色队列中的对象，并将自身标记为黑色 清除所有不可达的白色对象 复制收集 内存分配 Tcmalloc算法 Tcmalloc(Thread Caching Malloc) 是 google 为 c 语言开发的运行时内存分配算法. 其核心思想是多级管理，从而降低锁的粒度. Go runtime 的内存分配就采用了 Tcmalloc 算法. golang 内存分配 go启动申请3块空间 spans,bitmap,arena. © cc all right reserved，powered by GitbookUpdated at 2020-05-29 09:30:10 "},"05-language/go/tcp.html":{"url":"05-language/go/tcp.html","title":"tcp","keywords":"","body":"服务器端示例： //go-tcpsock/server.go func HandleConn(conn net.Conn) { defer conn.Close() for { // read from the connection // ... ... // write to the connection //... ... } } func main() { listen, err := net.Listen(\"tcp\", \":8888\") if err != nil { fmt.Println(\"listen error: \", err) return } for { conn, err := listen.Accept() if err != nil { fmt.Println(\"accept error: \", err) break } // start a new goroutine to handle the new connection go HandleConn(conn) } } 客户端示例： //阻塞 conn, err := net.Dial(\"tcp\", \"www.baidu.com:80\") if err != nil { //handle error } //超时 conn, err := net.DialTimeout(\"tcp\", \"www.baidu.com:80\", 2*time.Second) if err != nil { //handle error } 服务器backlog满时，会阻塞客户端Dail，直到服务器一次accept 。 socket的属性 SetKeepAliveSetKeepAlivePeriodSetLingerSetNoDelay （默认no delay）SetWriteBufferSetReadBuffer © cc all right reserved，powered by GitbookUpdated at 2020-05-29 10:17:07 "},"05-language/go/websocket.html":{"url":"05-language/go/websocket.html","title":"websocket","keywords":"","body":"示例： package impl import ( \"github.com/gorilla/websocket\" \"sync\" \"errors\" ) type Connection struct{ wsConnect *websocket.Conn inChan chan []byte outChan chan []byte closeChan chan byte mutex sync.Mutex // 对closeChan关闭上锁 isClosed bool // 防止closeChan被关闭多次 } func InitConnection(wsConn *websocket.Conn)(conn *Connection ,err error){ conn = &Connection{ wsConnect:wsConn, inChan: make(chan []byte,1000), outChan: make(chan []byte,1000), closeChan: make(chan byte,1), } // 启动读协程 go conn.readLoop(); // 启动写协程 go conn.writeLoop(); return } func (conn *Connection)ReadMessage()(data []byte , err error){ select{ case data = © cc all right reserved，powered by GitbookUpdated at 2020-05-29 10:17:04 "},"05-language/go/sync.Map.html":{"url":"05-language/go/sync.Map.html","title":"sync.Map","keywords":"","body":"sync.Map 开箱即用 package main import ( \"sync\" \"fmt\" ) func main() { //开箱即用 var sm sync.Map //store 方法,添加元素 sm.Store(1,\"a\") //Load 方法，获得value if v,ok:=sm.Load(1);ok{ fmt.Println(v) } //LoadOrStore方法，获取或者保存 //参数是一对key：value，如果该key存在且没有被标记删除则返回原先的value（不更新）和true；不存在则store，返回该value 和false if vv,ok:=sm.LoadOrStore(1,\"c\");ok{ fmt.Println(vv) } if vv,ok:=sm.LoadOrStore(2,\"c\");!ok{ fmt.Println(vv) } //遍历该map，参数是个函数，该函数参的两个参数是遍历获得的key和value，返回一个bool值，当返回false时，遍历立刻结束。 sm.Range(func(k,v interface{})bool{ fmt.Print(k) fmt.Print(\":\") fmt.Print(v) fmt.Println() return true }) } 运行结果： a a c 1:a 2:c © cc all right reserved，powered by GitbookUpdated at 2020-09-20 10:03:37 "},"05-language/C++/":{"url":"05-language/C++/","title":"C++","keywords":"","body":"C++知识点 templete STL 智能指针 epoll select 线程间通信 线程间同步 树 Lamda表达式 c++11/c++17/c++20 © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:35:15 "},"05-language/vue/":{"url":"05-language/vue/","title":"Vue","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-10-31 15:19:45 "},"06-Devops/":{"url":"06-Devops/","title":"Devops","keywords":"","body":" Golang C++ vue © cc all right reserved，powered by GitbookUpdated at 2020-10-31 15:26:18 "},"06-Devops/kubernetes/":{"url":"06-Devops/kubernetes/","title":"kubernetes","keywords":"","body":" csi crd rabc API Aggregation © cc all right reserved，powered by GitbookUpdated at 2020-07-18 10:47:17 "},"06-Devops/kubernetes/csi.html":{"url":"06-Devops/kubernetes/csi.html","title":"csi","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-05-01 23:17:05 "},"05-language/C++/templete.html":{"url":"05-language/C++/templete.html","title":"templete","keywords":"","body":"1、templete理解 模板本质是对类型参数话的一种工具 templete 跟 templete 没有本质的区别 2、定义 函数模板 template 返回类型 函数名(参数列表) { 函数体 } 例： templete inline T func(T &a，T &b) 类模板 template class 类名 {...}; 例： template class A{ public: T g(T a,T b); A(); }; template A::A(){} template T A::g(T a,T b){ return a+b; } void main(){ A a; cout 模板专门化 有些特殊类型需要特殊处理，需要重载定义一次模板 例如： template void swap(std::vector& t1, std::vector& t2) { t1.swap(t2); }. © cc all right reserved，powered by GitbookUpdated at 2020-09-20 14:32:18 "},"05-language/C++/STL.html":{"url":"05-language/C++/STL.html","title":"STL","keywords":"","body":"STL: STL笔试面试题总结（干货）_zzb2019的博客-CSDN博客 © cc all right reserved，powered by GitbookUpdated at 2020-09-21 22:23:55 "},"05-language/C++/智能指针.html":{"url":"05-language/C++/智能指针.html","title":"智能指针","keywords":"","body":"智能指针（C++11）： 全生命周期管理在堆上分配的内存。可自动释放，避免内存泄露。 unique_ptr 独占的形式，保证同一时间只有一个智能指针指向对象 可通过move 移交所有权 unique_ptr ps1, ps2; ps1 = demo(\"hello\"); ps2 = move(ps1); ps1 = demo(\"alexia\"); cout shared_ptr 采用引用计数的形式管理对象 主要成员: use_count：返回引用计数的个数 unique：返回是否独占所有权 use_count =1 swap: 交换两个share_ptr 对象 reset: 放弃所有权，让引用计数减一 get: 返回内部对象，就是指针。 weak_ptr 为了解决share_ptr循环引用的情况，不会管理指针的生命周期，只是提供了一种访问能力。 使用前需要检查合法性。expired(); © cc all right reserved，powered by GitbookUpdated at 2020-09-20 16:00:52 "},"05-language/C++/线程间通信.html":{"url":"05-language/C++/线程间通信.html","title":"线程间通信","keywords":"","body":"线程间通信： GitHub - wmdboke/linux-ipcs: Linux进程间通信(Inter-Process Communication)方式汇总 © cc all right reserved，powered by GitbookUpdated at 2020-09-21 22:07:40 "},"05-language/C++/线程间同步.html":{"url":"05-language/C++/线程间同步.html","title":"线程间同步","keywords":"","body":"线程之间同步： 互斥锁 #include int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);//互斥初始化 int pthread_mutex_destroy(pthread_mutex_t *mutex);//销毁互斥 int pthread_mutex_lock(pthread_mutex_t *mutex);//锁定互斥 int pthread_mutex_unlock(pthread_mutex_t *mutex);//解锁互斥 int pthread_mutex_trylock(pthread_mutex_t *mutex);//销毁互斥 eg.pthread_t mutex; pthread_mutex_init(&mutex, NULL); pthread_mutex_lock(&mutex); ... pthread_mutex_unlock(&mutex); pthread_mutex_detroy(&mutex); 读写锁 #include int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *rwlockattr);//初始化读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);//销毁读写锁 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);//读模式锁定读写锁 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);//写模式锁定读写锁 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);//解锁读写锁 eg.pthread_rwlock_t q_lock; pthread_rwlock_init(&q_lock, NULL); pthread_rwlock_rdlock(&q_lock); ... pthread_rwlock_unlock(&q_lock); pthread_rwlock_detroy(&q_lock); 信号量 #include sem_t sem_event; int sem_init(sem_t *sem, int pshared, unsigned int value);//初始化一个信号量 int sem_destroy(sem_t * sem);//销毁信号量 int sem_post(sem_t * sem);//信号量增加1 int sem_wait(sem_t * sem);//信号量减少1 int sem_getvalue(sem_t * sem, int * sval);//获取当前信号量的值 条件变量 #include int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);//初始化条件变量 int pthread_cond_destroy(pthread_cond_t *cond);//销毁条件变量 int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);//无条件等待条件变量变为真 int pthread_cond_timewait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *tsptr);//在给定时间内，等待条件变量变为真 eg.pthread_mutex_t mutex; pthread_cond_t cond; ... pthread_mutex_lock(&mutex); pthread_cond_wait(&cond, &mutex); ... pthread_mutex_unlock(&mutex); 自旋锁 处于忙等的状态，不想线程切换，占用锁的时间短 © cc all right reserved，powered by GitbookUpdated at 2020-09-21 21:21:27 "},"05-language/C++/Lamda表达式.html":{"url":"05-language/C++/Lamda表达式.html","title":"Lamda表达式","keywords":"","body":"Lamda表达式(C++11): 本质是匿名函数。具体形式如下： [capture list] (params list) mutable exception-> return type { function body } capture list：捕获外部变量列表 params list：形参列表 mutable指示符：用来说用是否可以修改捕获的变量,能修改传递进来的拷贝的变量。 exception：异常设定 return type：返回类型 function body：函数体 最简单的是：{}; © cc all right reserved，powered by GitbookUpdated at 2020-09-20 15:57:48 "},"02-Network/":{"url":"02-Network/","title":"Network","keywords":"","body":"从头开始学网络 namespace tun/tap route 网卡配置文件 © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:25:07 "},"02-Network/namespace.html":{"url":"02-Network/namespace.html","title":"namespace","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-05-23 06:19:56 "},"02-Network/tun-tap.html":{"url":"02-Network/tun-tap.html","title":"tun/tap","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-05-23 06:20:03 "},"02-Network/route.html":{"url":"02-Network/route.html","title":"route","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-05-23 06:20:11 "},"02-Network/centos网卡配置文件.html":{"url":"02-Network/centos网卡配置文件.html","title":"网卡配置文件","keywords":"","body":"文件路径：/etc/sysconfig/network-scripts/ifcfg-eth0配置IP、掩码、网关:ethX DEVICE=\"eth0\" 此配置关联至的设备。设备名要与文件ifcfg-后ude内容保持一致 BOOTPROTO=none 引导协议：{none|static|dhcp|bootp} HWADDR=\"00:0C:29:26:62:92\" MAC地址：要与真实MAC地址保持一致，可省略 NM_CONTROLLED=\"yes\" 是否接受NetworkManager脚本控制：{yes|no} ONBOOT=\"yes\" 是否开机自动启动此网络设备{yes|no} TYPE=\"Ethernet\" 设备类型Etheraget Bridge（桥接） UUID=\"14351f7f-a726-4dfc-966e-dfb1f352f226\" 唯一标识，可省略 IPADDR= ip地址 NETMASK= 掩码 GATEWAY= 默认网关 DNS1= DNS1服务地址 IPV6INIT=no 是否开启ipv6 USERCTL=no 是否允许普通用户操作网卡 PEERDNS={yes|no} 是否允许DHCP服务分配地址时直接更新/etc/resolv。conf中的DNS服务器地址 © cc all right reserved，powered by GitbookUpdated at 2020-05-26 08:54:35 "},"03-Databases/":{"url":"03-Databases/","title":"Database","keywords":"","body":" mysql redis memcache etcd mongodb © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:47:23 "},"05-Language/C++/":{"url":"05-Language/C++/","title":"C++","keywords":"","body":"C++知识点 templete STL 智能指针 epoll select 线程间通信 线程间同步 树 Lamda表达式 c++11/c++17/c++20 © cc all right reserved，powered by GitbookUpdated at 2020-11-01 09:35:15 "},"05-Language/C++/templete.html":{"url":"05-Language/C++/templete.html","title":"templete","keywords":"","body":"1、templete理解 模板本质是对类型参数话的一种工具 templete 跟 templete 没有本质的区别 2、定义 函数模板 template 返回类型 函数名(参数列表) { 函数体 } 例： templete inline T func(T &a，T &b) 类模板 template class 类名 {...}; 例： template class A{ public: T g(T a,T b); A(); }; template A::A(){} template T A::g(T a,T b){ return a+b; } void main(){ A a; cout 模板专门化 有些特殊类型需要特殊处理，需要重载定义一次模板 例如： template void swap(std::vector& t1, std::vector& t2) { t1.swap(t2); }. © cc all right reserved，powered by GitbookUpdated at 2020-09-20 14:32:18 "},"05-Language/C++/STL.html":{"url":"05-Language/C++/STL.html","title":"STL","keywords":"","body":"STL: STL笔试面试题总结（干货）_zzb2019的博客-CSDN博客 © cc all right reserved，powered by GitbookUpdated at 2020-09-21 22:23:55 "},"05-Language/C++/智能指针.html":{"url":"05-Language/C++/智能指针.html","title":"智能指针","keywords":"","body":"智能指针（C++11）： 全生命周期管理在堆上分配的内存。可自动释放，避免内存泄露。 unique_ptr 独占的形式，保证同一时间只有一个智能指针指向对象 可通过move 移交所有权 unique_ptr ps1, ps2; ps1 = demo(\"hello\"); ps2 = move(ps1); ps1 = demo(\"alexia\"); cout shared_ptr 采用引用计数的形式管理对象 主要成员: use_count：返回引用计数的个数 unique：返回是否独占所有权 use_count =1 swap: 交换两个share_ptr 对象 reset: 放弃所有权，让引用计数减一 get: 返回内部对象，就是指针。 weak_ptr 为了解决share_ptr循环引用的情况，不会管理指针的生命周期，只是提供了一种访问能力。 使用前需要检查合法性。expired(); © cc all right reserved，powered by GitbookUpdated at 2020-09-20 16:00:52 "},"05-Language/C++/线程间通信.html":{"url":"05-Language/C++/线程间通信.html","title":"线程间通信","keywords":"","body":"线程间通信： GitHub - wmdboke/linux-ipcs: Linux进程间通信(Inter-Process Communication)方式汇总 © cc all right reserved，powered by GitbookUpdated at 2020-09-21 22:07:40 "},"05-Language/C++/线程间同步.html":{"url":"05-Language/C++/线程间同步.html","title":"线程间同步","keywords":"","body":"线程之间同步： 互斥锁 #include int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);//互斥初始化 int pthread_mutex_destroy(pthread_mutex_t *mutex);//销毁互斥 int pthread_mutex_lock(pthread_mutex_t *mutex);//锁定互斥 int pthread_mutex_unlock(pthread_mutex_t *mutex);//解锁互斥 int pthread_mutex_trylock(pthread_mutex_t *mutex);//销毁互斥 eg.pthread_t mutex; pthread_mutex_init(&mutex, NULL); pthread_mutex_lock(&mutex); ... pthread_mutex_unlock(&mutex); pthread_mutex_detroy(&mutex); 读写锁 #include int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *rwlockattr);//初始化读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);//销毁读写锁 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);//读模式锁定读写锁 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);//写模式锁定读写锁 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);//解锁读写锁 eg.pthread_rwlock_t q_lock; pthread_rwlock_init(&q_lock, NULL); pthread_rwlock_rdlock(&q_lock); ... pthread_rwlock_unlock(&q_lock); pthread_rwlock_detroy(&q_lock); 信号量 #include sem_t sem_event; int sem_init(sem_t *sem, int pshared, unsigned int value);//初始化一个信号量 int sem_destroy(sem_t * sem);//销毁信号量 int sem_post(sem_t * sem);//信号量增加1 int sem_wait(sem_t * sem);//信号量减少1 int sem_getvalue(sem_t * sem, int * sval);//获取当前信号量的值 条件变量 #include int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);//初始化条件变量 int pthread_cond_destroy(pthread_cond_t *cond);//销毁条件变量 int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);//无条件等待条件变量变为真 int pthread_cond_timewait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *tsptr);//在给定时间内，等待条件变量变为真 eg.pthread_mutex_t mutex; pthread_cond_t cond; ... pthread_mutex_lock(&mutex); pthread_cond_wait(&cond, &mutex); ... pthread_mutex_unlock(&mutex); 自旋锁 处于忙等的状态，不想线程切换，占用锁的时间短 © cc all right reserved，powered by GitbookUpdated at 2020-09-21 21:21:27 "},"05-Language/C++/Lamda表达式.html":{"url":"05-Language/C++/Lamda表达式.html","title":"Lamda表达式","keywords":"","body":"Lamda表达式(C++11): 本质是匿名函数。具体形式如下： [capture list] (params list) mutable exception-> return type { function body } capture list：捕获外部变量列表 params list：形参列表 mutable指示符：用来说用是否可以修改捕获的变量,能修改传递进来的拷贝的变量。 exception：异常设定 return type：返回类型 function body：函数体 最简单的是：{}; © cc all right reserved，powered by GitbookUpdated at 2020-09-20 15:57:48 "},"05-Language/vue/":{"url":"05-Language/vue/","title":"Vue","keywords":"","body":"© cc all right reserved，powered by GitbookUpdated at 2020-10-31 15:19:45 "}}